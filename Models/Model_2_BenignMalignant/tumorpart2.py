# -*- coding: utf-8 -*-
"""Tumorpart2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pjgOrDWCrtrmipWMTdMaSeaA41em9Qdy
"""

#%tensorflow_version 2.x
#TensorFlow and tf.keras
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.preprocessing import image
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import EarlyStopping

import numpy as np
import matplotlib.pyplot as plt
import os

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!mv kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d srinivasbece/brain-tumor-databasebtd600

import zipfile
with zipfile.ZipFile("brain-tumor-databasebtd600.zip", 'r') as zip_ref:
    zip_ref.extractall("/content/btd600")

train_path = "/content/btd600/Brain Tumor Database(BTD-660)/training"
test_path = "/content/btd600/Brain Tumor Database(BTD-660)/testing"
validation_path = "/content/btd600/Brain Tumor Database(BTD-660)/validation"

class_names = ['benign', 'malignent']

#Preprocess training data
train_datagen = ImageDataGenerator(
    rescale=1./255,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
)

train_generator = train_datagen.flow_from_directory(
    train_path,
    target_size=(150, 150), #Adjusting the target size as needed
    batch_size=32,
    class_mode='binary',
    classes=class_names
)

# Preprocess validation data (only rescale, no augmentation)
validation_datagen = ImageDataGenerator(rescale=1./255)

validation_generator = validation_datagen.flow_from_directory(
    validation_path,
    target_size=(150, 150),
    batch_size=32,
    class_mode='binary',
    classes=class_names,
    shuffle=False # Not strictly necessary for validation but good practice
)

#Preprocess testing data
test_datagen = ImageDataGenerator(rescale=1./255)

test_generator = test_datagen.flow_from_directory(
    test_path,
    target_size=(150, 150), #Adjusting the target size as needed
    batch_size=32,
    class_mode='binary',
    classes=class_names,
    shuffle=False  #Keep order for evaluation
)
#Defining the model
model = keras.Sequential([
    keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)), #Input shapes adjusted for color images
    keras.layers.MaxPooling2D((2, 2)),
    # keras.layers.Dropout(0.1),

    keras.layers.Conv2D(64, (3, 3), activation='relu'),
    keras.layers.MaxPooling2D((2, 2)),
    # keras.layers.Dropout(0.1),

    keras.layers.Conv2D(128, (3, 3), activation='relu'),
    keras.layers.MaxPooling2D((2, 2)),
    # keras.layers.Dropout(0.1),

    keras.layers.Flatten(),
    keras.layers.Dense(128, activation='relu'),
    #  keras.layers.Dropout(0.2), # Add Dropout before the final classification layer
    keras.layers.Dense(1, activation='sigmoid') # Output layer for binary classification
])

#Compiling the model
model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

model.summary()

# Define EarlyStopping callback
early_stopping = EarlyStopping(
    monitor='val_loss',
    patience=5,
    restore_best_weights=True # Restore model weights from the epoch with best val_loss
)

# Training the model with validation data and early stopping
model.fit(
    train_generator,
    epochs=50,
    validation_data=validation_generator,
    callbacks=[early_stopping]
)

#Evaluating the model
test_loss, test_acc = model.evaluate(test_generator, verbose=1)

print('Test accuracy:', test_acc)

COLOR = 'black'
plt.rcParams['text.color'] = COLOR
plt.rcParams['axes.labelcolor'] = COLOR

# --- CHANGE 1: Update class_names for your new dataset ---
class_names = ['benign', 'malignent']

def predict(model, image_array, correct_label):
    # Add the batch dimension (model expects input shape like (1, 150, 150, 3))
    prediction = model.predict(np.expand_dims(image_array, axis=0))

    # --- CHANGE 2: Adapt prediction logic for binary (sigmoid) output ---
    # For binary classification with sigmoid activation (output neuron 1),
    # the prediction is a single probability for the positive class (malignant).
    # If this probability is > 0.5, it's 'malignant' (index 1), otherwise 'benign' (index 0).
    predicted_probability = prediction[0][0] # Access the single probability value
    if predicted_probability > 0.5:
        predicted_class_index = 0 # Corresponds to 'malignant'
    else:
        predicted_class_index = 1 # Corresponds to 'benign'

    predicted_class_name = class_names[predicted_class_index]
    true_class_name = class_names[correct_label] # correct_label will be 0 or 1 from generator

    # --- CHANGE 3: Adjust title/xlabel to show probability ---
    # You might want to display the probability as well for binary output
    show_image(image_array, true_class_name, predicted_class_name, predicted_probability)

def show_image(img, label, guess, probability):
    plt.figure(figsize=(6, 6)) # Adjust figure size for better display
    plt.imshow(img)
    plt.title(f"Expected: {label}", color=COLOR)
    # Display probability along with guess
    plt.xlabel(f"Guess: {guess} ", color=COLOR)
    plt.colorbar()
    plt.grid(False)
    plt.show()

def get_number(max_index):
    while True:
        num_str = input(f"Pick a number between 0 and {max_index}: ")
        if num_str.isdigit():
            num = int(num_str)
            if 0 <= num <= max_index:
                return num
            else:
                print(f"Number out of range. Please pick a number between 0 and {max_index}.")
        else:
            print("Invalid input. Please enter a whole number.")

# --- Make sure these variables are accessible from your training code ---
# Getting the labels from the test generator
# Note: test_generator should be defined from your previous training setup
test_labels = test_generator.classes

# Getting the filenames from the test generator
test_filenames = test_generator.filenames

# Getting the total number of test samples
num_test_samples = len(test_generator.filenames)

# --- Code to pick a random image for prediction ---
print(f"Total test samples available: {num_test_samples}")
if num_test_samples == 0:
    print("No test samples found. Please check your test_generator setup.")
else:
    import random
    random_index = random.randint(0, num_test_samples - 1)
    print(f"Predicting for random sample at index: {random_index}")

    # Ensure test_path is correctly set from your previous code
    img_path = os.path.join(test_path, test_filenames[random_index])

    # Load and preprocess the image
    img = image.load_img(img_path, target_size=(150, 150))
    img_array = image.img_to_array(img) / 255.0 # Normalize pixel values to [0, 1]

    # Get the true label for this image
    label = test_labels[random_index]

    # Call the prediction function
    predict(model, img_array, label)

# --- Code to ask the user to pick an input index (uncomment to use) ---
# if num_test_samples > 0:
#     print("\n--- Or pick a specific image to predict ---")
#     num = get_number(num_test_samples - 1)
#     img_path_user = os.path.join(test_path, test_filenames[num])
#     img_user = image.load_img(img_path_user, target_size=(150, 150))
#     img_array_user = image.img_to_array(img_user) / 255.0
#     label_user = test_labels[num]
#     predict(model, img_array_user, label_user)