# -*- coding: utf-8 -*-
"""Tumorpart1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P2heQRZxwA2lG-KSh5grbQfs7rGLL_qx
"""

#%tensorflow_version 2.x
#TensorFlow and tf.keras
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.preprocessing import image
from tensorflow.keras.preprocessing.image import ImageDataGenerator

import numpy as np
import matplotlib.pyplot as plt
import os

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!mv kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d masoudnickparvar/brain-tumor-mri-dataset

import zipfile
with zipfile.ZipFile("brain-tumor-mri-dataset.zip", 'r') as zip_ref:
    zip_ref.extractall("/content/dataset")

train_path = "/content/dataset/Training"
test_path = "/content/dataset/Testing"

class_names = ['glioma', 'meningioma', 'notumor', 'pituitary']

#Preprocess training data
train_datagen = ImageDataGenerator(
    rescale=1./255,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
)

train_generator = train_datagen.flow_from_directory(
    train_path,
    target_size=(150, 150), #Adjusting the target size as needed
    batch_size=32,
    class_mode='categorical',
    classes=class_names
)

#Preprocess testing data
test_datagen = ImageDataGenerator(rescale=1./255)

test_generator = test_datagen.flow_from_directory(
    test_path,
    target_size=(150, 150), #Adjusting the target size as needed
    batch_size=32,
    class_mode='categorical',
    classes=class_names,
    shuffle=False  #Keep order for evaluation
)
#Defining the model
model = keras.Sequential([
    keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)), #Input shapes adjusted for color images
    keras.layers.MaxPooling2D((2, 2)),
    keras.layers.Conv2D(64, (3, 3), activation='relu'),
    keras.layers.MaxPooling2D((2, 2)),
    keras.layers.Conv2D(128, (3, 3), activation='relu'),
    keras.layers.MaxPooling2D((2, 2)),
    keras.layers.Flatten(),
    keras.layers.Dense(128, activation='relu'),
    keras.layers.Dense(len(class_names), activation='softmax') #Output layer with no. of classes
])

#Compiling the model
model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

model.summary()

#Training the model
model.fit(train_generator, epochs=10)

#Evaluating the model
test_loss, test_acc = model.evaluate(test_generator, verbose=1)

print('Test accuracy:', test_acc)

COLOR = 'black'
plt.rcParams['text.color'] = COLOR
plt.rcParams['axes.labelcolor'] = COLOR

class_names = ['glioma', 'meningioma', 'notumor', 'pituitary']

def predict(model, image_array, correct_label):
    prediction = model.predict(np.expand_dims(image_array, axis=0)) #Adding the batch dimension
    predicted_class_index = np.argmax(prediction)
    predicted_class_name = class_names[predicted_class_index]
    true_class_name = class_names[correct_label]

    show_image(image_array, true_class_name, predicted_class_name)

def show_image(img, label, guess):
    plt.figure()
    plt.imshow(img)
    plt.title(f"Expected: {label}")
    plt.xlabel(f"Guess: {guess}")
    plt.colorbar()
    plt.grid(False)
    plt.show()

def get_number(max_index):
    while True:
        num_str = input(f"Pick a number between 0 and {max_index}: ")
        if num_str.isdigit():
            num = int(num_str)
            if 0 <= num <= max_index:
                return num
        else:
            print("Invalid input. Please enter a number.")

#Getting the labels from the test generator
test_labels = test_generator.classes
#Getting the filenames from the test generator
test_filenames = test_generator.filenames
#Getting the total number of test samples
num_test_samples = len(test_generator.filenames)

#Taking a random index input from the test set
import random
random_index = random.randint(0, num_test_samples - 1)
img_path = os.path.join(test_path, test_filenames[random_index])
img = image.load_img(img_path, target_size=(150, 150))
img_array = image.img_to_array(img) / 255.0 #To normalize the pixel values

label = test_labels[random_index]
predict(model, img_array, label)

#To ask the user to pick an input index:
#num = get_number(num_test_samples - 1)
#img_path = os.path.join(test_path, test_filenames[num])
#img = image.load_img(img_path, target_size=(150, 150))
#img_array = image.img_to_array(img) / 255.0
#label = test_labels[num]
#predict(model, img_array, label)